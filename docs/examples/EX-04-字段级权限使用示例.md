# 字段级权限（Field-Level Security）使用示例

**版本**: v0.8.0
**日期**: 2025-11-21
**状态**: 已实施（后端）

## 1. 概述

字段级权限允许基于角色控制用户对特定实体字段的读写访问权限。本文档展示如何在 API 端点中使用字段级权限功能。

## 2. 核心组件

### 2.1 服务层

- **`IFieldPermissionService`**: 权限管理接口
- **`FieldPermissionService`**: 权限管理实现
- **`FieldFilterService`**: 运行时字段过滤服务

### 2.2 扩展方法

- **`FieldFilterExtensions`**: 便捷的字段过滤扩展方法

## 3. 使用场景

### 场景 1: 读取数据时过滤字段

```csharp
// 示例：获取客户详情（只返回用户有权限读取的字段）
group.MapGet("/customers/{id:int}", async (
    int id,
    ClaimsPrincipal user,
    IRepository<Customer> repo,
    FieldFilterService filterService) =>
{
    var customer = await repo.GetByIdAsync(id);

    if (customer == null)
    {
        return Results.NotFound();
    }

    // 使用 FieldFilterService 过滤字段
    return await filterService.FilteredOkAsync(user, "Customer", customer);
})
.WithName("GetCustomer")
.WithSummary("获取客户详情（自动过滤字段）");
```

### 场景 2: 获取列表时过滤字段

```csharp
// 示例：获取客户列表（只返回用户有权限读取的字段）
group.MapGet("/customers", async (
    ClaimsPrincipal user,
    IRepository<Customer> repo,
    FieldFilterService filterService) =>
{
    var customers = await repo.GetAllAsync();

    // 使用 FieldFilterService 过滤数组
    return await filterService.FilteredOkArrayAsync(user, "Customer", customers);
})
.WithName("GetCustomers")
.WithSummary("获取客户列表（自动过滤字段）");
```

### 场景 3: 创建/更新时验证字段权限

```csharp
// 示例：更新客户（只允许修改有权限的字段）
group.MapPut("/customers/{id:int}", async (
    int id,
    ClaimsPrincipal user,
    UpdateCustomerRequest request,
    IRepository<Customer> repo,
    FieldFilterService filterService) =>
{
    // 1. 验证用户是否有权限修改这些字段
    var validation = await filterService.ValidateWritePermissionsAsync(user, "Customer", request);

    if (!validation.IsValid)
    {
        // 返回 403 Forbidden，包含未授权字段列表
        return validation.ErrorResult!;
    }

    // 2. 执行更新操作
    var customer = await repo.GetByIdAsync(id);
    if (customer == null)
    {
        return Results.NotFound();
    }

    // 更新字段...
    await repo.UpdateAsync(customer);

    return Results.Ok(customer);
})
.WithName("UpdateCustomer")
.WithSummary("更新客户（验证字段权限）");
```

### 场景 4: 使用链式调用简化代码

```csharp
// 示例：使用 OrElseAsync 简化验证逻辑
group.MapPost("/customers", async (
    ClaimsPrincipal user,
    CreateCustomerRequest request,
    IRepository<Customer> repo,
    FieldFilterService filterService) =>
{
    // 验证字段权限，失败则直接返回错误
    return await filterService
        .ValidateWritePermissionsAsync(user, "Customer", request)
        .OrElseAsync(async () =>
        {
            // 只有验证通过才会执行这里
            var customer = new Customer
            {
                // 映射字段...
            };

            await repo.AddAsync(customer);
            return Results.Created($"/api/customers/{customer.Id}", customer);
        });
})
.WithName("CreateCustomer")
.WithSummary("创建客户（验证字段权限）");
```

### 场景 5: 字典数据的字段过滤

```csharp
// 示例：处理字典格式的数据
group.MapGet("/customers/{id}/metadata", async (
    int id,
    ClaimsPrincipal user,
    FieldFilterService filterService) =>
{
    var userId = user.FindFirstValue(ClaimTypes.NameIdentifier) ?? string.Empty;

    // 原始数据（字典格式）
    var metadata = new Dictionary<string, object?>
    {
        { "Name", "张三" },
        { "Email", "zhangsan@example.com" },
        { "Salary", 50000 },
        { "Phone", "13800138000" }
    };

    // 过滤字段
    var filtered = await filterService.FilterWriteFieldsAsync(user, "Customer", metadata);

    return Results.Ok(filtered);
})
.WithName("GetCustomerMetadata")
.WithSummary("获取客户元数据（自动过滤字段）");
```

## 4. 字段权限配置

### 4.1 设置角色的字段权限

```http
POST /api/field-permissions/role/{roleId}/entity/Customer/bulk
Content-Type: application/json

{
  "permissions": [
    {
      "fieldName": "Name",
      "canRead": true,
      "canWrite": true,
      "remarks": "基本信息"
    },
    {
      "fieldName": "Email",
      "canRead": true,
      "canWrite": true
    },
    {
      "fieldName": "Salary",
      "canRead": false,
      "canWrite": false,
      "remarks": "敏感字段：薪资"
    },
    {
      "fieldName": "Phone",
      "canRead": true,
      "canWrite": false,
      "remarks": "可读但不可修改"
    }
  ]
}
```

### 4.2 查询用户可读/可写字段

```http
# 获取当前用户对 Customer 实体的可读字段
GET /api/field-permissions/user/entity/Customer/readable-fields

# 响应
["Name", "Email", "Phone"]

# 获取当前用户对 Customer 实体的可写字段
GET /api/field-permissions/user/entity/Customer/writable-fields

# 响应
["Name", "Email"]
```

## 5. 权限聚合规则

- **多角色情况**：用户如果属于多个角色，字段权限取**并集**（最宽松）
- **默认行为**：如果没有显式设置权限，默认**允许读取，禁止写入**
- **宽松模式**：如果实体没有任何字段权限配置，默认**允许所有操作**

## 6. 最佳实践

### 6.1 敏感字段保护

对于敏感字段（如薪资、身份证号），建议：

1. 明确设置 `CanRead = false` 和 `CanWrite = false`
2. 只对需要的角色开放权限
3. 添加 `Remarks` 说明字段敏感性

### 6.2 性能优化

1. **批量操作**：使用 `BulkUpsertPermissions` 而非单个更新
2. **缓存权限**：考虑在应用层缓存用户的字段权限列表
3. **最小化过滤**：只在必要的端点启用字段过滤

### 6.3 错误处理

```csharp
try
{
    var validation = await filterService.ValidateWritePermissionsAsync(user, entityType, request);

    if (!validation.IsValid)
    {
        _logger.LogWarning("User {UserId} attempted to write unauthorized fields: {Fields}",
            userId, string.Join(", ", validation.ErrorResult));
        return validation.ErrorResult!;
    }

    // 执行业务逻辑...
}
catch (Exception ex)
{
    _logger.LogError(ex, "Field permission check failed");
    return Results.Problem("Internal server error");
}
```

## 7. 安全注意事项

1. **字段名大小写不敏感**：系统使用 `StringComparer.OrdinalIgnoreCase` 比较字段名
2. **嵌套对象过滤**：支持递归过滤嵌套的 JSON 对象
3. **数组过滤**：支持过滤对象数组中每个元素的字段
4. **日志记录**：所有字段过滤操作都有日志记录，便于审计

## 8. 故障排查

### 问题 1: 字段被意外过滤

**原因**：用户的角色没有对该字段的读取权限

**解决**：
```http
# 检查用户的可读字段列表
GET /api/field-permissions/user/entity/{entityType}/readable-fields

# 为角色添加字段权限
POST /api/field-permissions/role/{roleId}/entity/{entityType}/field/{fieldName}
{
  "canRead": true,
  "canWrite": false
}
```

### 问题 2: 写入操作被拒绝

**原因**：用户的角色没有对某些字段的写入权限

**解决**：检查响应中的 `unauthorizedFields` 列表，并调整角色权限

### 问题 3: 性能问题

**原因**：每次请求都查询数据库获取权限

**建议**：
1. 考虑在用户登录时缓存权限
2. 使用 `IMemoryCache` 缓存字段权限
3. 只在必要的端点启用字段过滤

## 9. 下一步

- [ ] 实现前端 UI（角色管理页面的字段权限标签页）
- [ ] 添加字段权限缓存机制
- [ ] 实现字段权限继承（从父角色继承权限）
- [ ] 添加字段权限审计日志

---

**相关文档**:
- `PLAN-03.md` - v0.8.0 开发路线图
- `API-01-接口文档.md` - 字段权限 API 文档

**最后更新**: 2025-11-21
