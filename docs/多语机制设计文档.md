# BobCRM 多语机制设计文档

## 概述

BobCRM 实现了两种独立的多语机制：

1. **UI 资源多语**：用于界面文本（按钮、标签、提示等）
2. **数据多语**：用于业务实体的属性（如客户名称、产品描述等）

## 1. UI 资源多语

### 实现方式

- **存储表**：`LocalizationResource`
- **字段**：`Key` (主键), `ZH`, `JA`, `EN`
- **使用**：前端通过 `I18nService.T("KEY")` 获取翻译

### 示例

```csharp
// 数据库中存储
{
  "Key": "BTN_LOGOUT",
  "ZH": "退出",
  "JA": "ログアウト",
  "EN": "Logout"
}

// 前端使用
<button>@I18n.T("BTN_LOGOUT")</button>
```

## 2. 数据多语

### 实现方式

使用**分表存储**的模式，为每个需要本地化的实体创建对应的 `{Entity}Localization` 表。

### 架构设计

#### 2.1 接口定义

```csharp
// 本地化数据必须实现的接口
public interface ILocalizationData
{
    int EntityId { get; set; }
    string Language { get; set; }
    string? GetLocalizedValue(string propertyName);
}
```

#### 2.2 特性标记

使用 `[Localizable]` 特性标记需要本地化的属性：

```csharp
public class Customer
{
    public int Id { get; set; }
    public string Code { get; set; } = string.Empty;
    
    [Localizable(Required = false, MaxLength = 256, Hint = "客户名称")]
    public string Name { get; set; } = string.Empty;
}
```

#### 2.3 本地化实体

创建 `CustomerLocalization` 表存储多语言数据：

```csharp
public class CustomerLocalization : ILocalizationData
{
    [Key]
    public int CustomerId { get; set; }
    
    [Key]
    public string Language { get; set; } = string.Empty;
    
    public string? Name { get; set; }
    
    // ILocalizationData 实现
    public int EntityId { get => CustomerId; set => CustomerId = value; }
    
    public string? GetLocalizedValue(string propertyName)
    {
        return propertyName switch
        {
            nameof(Name) => Name,
            _ => null
        };
    }
}
```

#### 2.4 查询逻辑

在查询时根据当前语言返回本地化值：

```csharp
public List<object> GetList()
{
    var lang = LangHelper.GetLang(_http.HttpContext!);
    
    // 尝试获取本地化名称
    Dictionary<int, string?> localizedNames = new();
    try
    {
        localizedNames = _repoLocalization.Query()
            .Where(l => l.Language == lang)
            .ToDictionary(l => l.CustomerId, l => l.Name);
    }
    catch
    {
        // 表不存在时使用默认名称
    }
    
    return customers.Select(c => new 
    { 
        id = c.Id, 
        code = c.Code, 
        name = localizedNames.ContainsKey(c.Id) && !string.IsNullOrEmpty(localizedNames[c.Id])
            ? localizedNames[c.Id]
            : c.Name 
    }).ToList();
}
```

### 添加新实体的多语支持

假设要为 `Product` 实体添加多语支持：

#### 步骤 1：标记可本地化属性

```csharp
public class Product
{
    public int Id { get; set; }
    
    [Localizable(Required = false, MaxLength = 256)]
    public string Name { get; set; } = string.Empty;
    
    [Localizable(Required = false, MaxLength = 1000)]
    public string? Description { get; set; }
}
```

#### 步骤 2：创建本地化实体

```csharp
public class ProductLocalization : ILocalizationData
{
    [Key, Column(Order = 0)]
    public int ProductId { get; set; }
    
    [Key, Column(Order = 1), MaxLength(8)]
    public string Language { get; set; } = string.Empty;
    
    [MaxLength(256)]
    public string? Name { get; set; }
    
    [MaxLength(1000)]
    public string? Description { get; set; }
    
    [ForeignKey("ProductId")]
    public Product? Product { get; set; }
    
    // ILocalizationData 实现
    public int EntityId { get => ProductId; set => ProductId = value; }
    
    public string? GetLocalizedValue(string propertyName)
    {
        return propertyName switch
        {
            nameof(Name) => Name,
            nameof(Description) => Description,
            _ => null
        };
    }
}
```

#### 步骤 3：添加到 DbContext

```csharp
public DbSet<ProductLocalization> ProductLocalizations => Set<ProductLocalization>();
```

#### 步骤 4：创建配置

```csharp
public class ProductLocalizationConfiguration : IEntityTypeConfiguration<ProductLocalization>
{
    public void Configure(EntityTypeBuilder<ProductLocalization> builder)
    {
        builder.HasKey(x => new { x.ProductId, x.Language });
        builder.HasOne(x => x.Product)
            .WithMany()
            .HasForeignKey(x => x.ProductId)
            .OnDelete(DeleteBehavior.Cascade);
    }
}
```

#### 步骤 5：更新查询逻辑

在 `ProductQueries` 中根据语言返回本地化值，类似于 `CustomerQueries`。

#### 步骤 6：初始化数据

在 `DatabaseInitializer` 中为测试数据添加多语言版本。

## 优势

1. **关注点分离**：UI 文本和业务数据分开处理
2. **易于扩展**：为任意实体添加多语支持只需遵循约定
3. **类型安全**：通过接口约束保证一致性
4. **容错处理**：表不存在时自动回退到默认值
5. **性能优化**：只查询需要的语言数据

## 约定

1. **命名**：本地化实体命名为 `{Entity}Localization`
2. **主键**：使用复合主键 `(EntityId, Language)`
3. **外键**：引用主实体的 `Id` 字段
4. **回退**：找不到本地化值时使用主实体的默认值
5. **语言码**：使用 ISO 639-1 标准（如 "zh", "ja", "en"）

