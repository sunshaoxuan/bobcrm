# I18N-02 元数据多语机制设计文档

## 概述

元数据多语机制是 BobCRM 中用于管理实体定义和字段元数据的国际化支持。该机制与 UI 资源多语（I18N-01）独立，专门处理实体和字段的显示名称及描述的多语言翻译。

## 设计原则

1. **动态语言支持**：不硬编码语言列表，从 `LocalizationLanguages` 表动态获取
2. **用户友好**：用户输入实际的多语言文本，系统自动生成和管理资源Key
3. **数据一致性**：多语言资源与元数据定义保持同步
4. **可扩展性**：添加新语言无需修改代码

## 架构设计

### 1. 数据库表结构

#### 1.1 MetadataLocalizationValues 表

动态结构的元数据多语言资源表：

```sql
CREATE TABLE MetadataLocalizationValues (
    Key VARCHAR(256),              -- 资源Key（主键1）
    Language VARCHAR(8),           -- 语言代码（主键2）
    Value TEXT NOT NULL,           -- 翻译文本
    CreatedAt TIMESTAMP,           -- 创建时间
    UpdatedAt TIMESTAMP,           -- 更新时间
    PRIMARY KEY (Key, Language)
);
```

**特点**：
- 复合主键 (Key, Language)
- 支持任意数量的语言
- 每个 Key 可以有多个语言版本

#### 1.2 Key 命名规范

- **实体显示名**：`ENTITY_{EntityName}`
  - 示例：`ENTITY_PRODUCT`

- **实体描述**：`ENTITY_{EntityName}_DESC`
  - 示例：`ENTITY_PRODUCT_DESC`

- **字段显示名**：`FIELD_{EntityName}_{FieldName}`
  - 示例：`FIELD_PRODUCT_PRICE`

### 2. 领域模型

#### 2.1 MetadataLocalizationValue 实体

```csharp
public class MetadataLocalizationValue
{
    [Key, Column(Order = 0), MaxLength(256)]
    public string Key { get; set; } = string.Empty;

    [Key, Column(Order = 1), MaxLength(8)]
    public string Language { get; set; } = string.Empty;

    [Required]
    public string Value { get; set; } = string.Empty;

    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;
}
```

#### 2.2 多语言文本 DTO（动态结构）

**前端 DTO：**

```csharp
/// <summary>
/// 多语言文本DTO - 使用 Dictionary 动态支持任意语言
/// </summary>
public class MultilingualTextDto : Dictionary<string, string?>
{
    public bool HasValue() => this.Values.Any(v => !string.IsNullOrWhiteSpace(v));

    public string? GetValue(string lang) =>
        TryGetValue(lang?.ToLowerInvariant() ?? "ja", out var value) ? value : null;

    public void SetValue(string lang, string? value) =>
        this[lang?.ToLowerInvariant() ?? "ja"] = value;
}
```

**后端 Record：**

```csharp
/// <summary>
/// 多语言文本记录 - 动态结构
/// Key: 语言代码（如 "ja", "zh", "en"）
/// Value: 该语言的文本
/// </summary>
public record MultilingualText : Dictionary<string, string?>
{
    public MultilingualText() : base(StringComparer.OrdinalIgnoreCase)
    {
    }
}
```

### 3. 服务层

#### 3.1 MetadataI18nService

核心服务类，负责元数据多语言资源的管理：

```csharp
public class MetadataI18nService
{
    // 获取系统支持的所有语言
    public Task<List<string>> GetAvailableLanguagesAsync();

    // 生成 Key
    public string GenerateEntityDisplayNameKey(string entityName);
    public string GenerateEntityDescriptionKey(string entityName);
    public string GenerateFieldDisplayNameKey(string entityName, string fieldName);

    // 保存/更新资源（接收 Dictionary）
    public Task<bool> SaveOrUpdateMetadataI18nAsync(
        string key, Dictionary<string, string?> translations);

    // 删除资源
    public Task<int> DeleteMetadataI18nAsync(string key);
    public Task<int> DeleteEntityRelatedI18nAsync(
        string entityName, IEnumerable<string>? fieldNames = null);

    // 查询资源
    public Task<Dictionary<string, string>?> GetMetadataI18nAsync(string key);
    public Task<bool> ExistsAsync(string key);
}
```

**服务注册**：

```csharp
// Program.cs
builder.Services.AddScoped<BobCrm.Api.Services.MetadataI18nService>();
```

### 4. API 端点

#### 4.1 创建实体定义

**端点**：`POST /api/entity-definitions`

**请求体**：

```json
{
  "namespace": "BobCrm.Domain.Custom",
  "entityName": "Product",
  "displayName": {
    "ja": "商品",
    "zh": "产品",
    "en": "Product",
    "ko": "제품"
  },
  "description": {
    "ja": "商品情報を管理します",
    "zh": "管理产品信息",
    "en": "Manage product information"
  },
  "fields": [
    {
      "propertyName": "Price",
      "displayName": {
        "ja": "価格",
        "zh": "价格",
        "en": "Price"
      },
      "dataType": "Decimal"
    }
  ]
}
```

**处理流程**：

1. 验证多语言显示名（至少提供一种语言）
2. 生成实体显示名 Key：`ENTITY_PRODUCT`
3. 保存多语言资源到 `MetadataLocalizationValues` 表
4. 为每个字段生成 Key 并保存多语言资源
5. 创建实体定义记录
6. 清除 `ILocalization` 缓存

### 5. 前端组件

#### 5.1 MultilingualInput 组件

动态多语言输入组件，从 API 获取语言列表：

```razor
<MultilingualInput @bind-Value="@_model.DisplayName" />
```

**特点**：
- 组件初始化时从 `/api/i18n/languages` 获取可用语言
- 动态渲染标签页
- 支持任意数量的语言
- 失败时降级到默认语言（ja, zh, en）

**实现细节**：

```csharp
protected override async Task OnInitializedAsync()
{
    // 从 API 获取语言列表
    _languages = await Http.GetFromJsonAsync<List<LanguageInfo>>(
        "/api/i18n/languages");

    // 初始化值字典
    foreach (var lang in _languages)
    {
        _values[lang.code] = Value?.GetValue(lang.code);
    }
}
```

## 工作流程

### 创建实体定义的完整流程

```
┌─────────────────────────────────────────────────────────┐
│ 1. 用户在前端输入多语言文本                                │
│    - 实体名：Product                                      │
│    - 显示名：{ "ja": "商品", "zh": "产品", "en": "Product" } │
└─────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────┐
│ 2. 前端发送请求到后端 API                                  │
│    POST /api/entity-definitions                          │
│    displayName: Dictionary<string, string?>              │
└─────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────┐
│ 3. 后端验证 Dictionary.Values 是否有非空值                │
└─────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────┐
│ 4. MetadataI18nService.GenerateEntityDisplayNameKey()   │
│    返回：ENTITY_PRODUCT                                  │
└─────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────┐
│ 5. SaveOrUpdateMetadataI18nAsync(key, translations)     │
│    遍历 Dictionary，为每种语言保存一条记录：               │
│    - (ENTITY_PRODUCT, ja, "商品")                        │
│    - (ENTITY_PRODUCT, zh, "产品")                        │
│    - (ENTITY_PRODUCT, en, "Product")                     │
└─────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────┐
│ 6. 创建 EntityDefinition 记录                            │
│    DisplayNameKey = "ENTITY_PRODUCT"                     │
└─────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────┐
│ 7. ILocalization.InvalidateCache()                       │
└─────────────────────────────────────────────────────────┘
```

## 添加新语言

### 数据库操作

在 `LocalizationLanguages` 表中添加新语言：

```sql
INSERT INTO LocalizationLanguages (Code, NativeName)
VALUES ('ko', '한국어');
```

### 无需代码修改

- 前端组件自动从 API 获取最新语言列表
- 后端服务动态支持所有 `LocalizationLanguages` 表中的语言
- 用户界面自动显示新的语言标签页

## 与 UI 资源多语的区别

| 特性 | UI 资源多语 (I18N-01) | 元数据多语 (I18N-02) |
|------|---------------------|---------------------|
| 用途 | 界面文本（按钮、标签） | 实体和字段的显示名 |
| 表结构 | `LocalizationResource`<br/>固定列 (ZH, JA, EN) | `MetadataLocalizationValues`<br/>动态行 (Key + Language) |
| Key 管理 | 手动定义 | 系统自动生成 |
| 数据录入 | 管理员在后台录入 | 用户创建实体时录入 |
| 语言扩展 | 需要修改表结构 | 仅需插入 `LocalizationLanguages` |

## 最佳实践

### 1. 验证规则

```csharp
// 至少提供一种语言的文本
if (translations == null || !translations.Any() ||
    !translations.Values.Any(v => !string.IsNullOrWhiteSpace(v)))
{
    return BadRequest("至少需要提供一种语言的文本");
}
```

### 2. 缓存管理

每次修改元数据多语言资源后，必须清除 `ILocalization` 缓存：

```csharp
await _db.SaveChangesAsync();
_localization.InvalidateCache();
```

### 3. 事务处理

将多语言资源保存和实体定义创建放在同一事务中：

```csharp
using var transaction = await _db.Database.BeginTransactionAsync();
try
{
    await metadataI18nService.SaveOrUpdateMetadataI18nAsync(key, translations);
    _db.EntityDefinitions.Add(definition);
    await _db.SaveChangesAsync();
    await transaction.CommitAsync();
}
catch
{
    await transaction.RollbackAsync();
    throw;
}
```

### 4. 错误处理

前端组件应该优雅降级：

```csharp
catch (Exception ex)
{
    Console.WriteLine($"Failed to load languages: {ex.Message}");
    // 使用默认语言
    _languages = new List<LanguageInfo>
    {
        new() { code = "ja", name = "日本語" },
        new() { code = "zh", name = "中文" },
        new() { code = "en", name = "English" }
    };
}
```

## 数据库迁移

```csharp
// 创建迁移
dotnet ef migrations add AddMetadataLocalizationValues

// 应用迁移
dotnet ef database update
```

**迁移内容**：

```csharp
migrationBuilder.CreateTable(
    name: "MetadataLocalizationValues",
    columns: table => new
    {
        Key = table.Column<string>(maxLength: 256),
        Language = table.Column<string>(maxLength: 8),
        Value = table.Column<string>(nullable: false),
        CreatedAt = table.Column<DateTime>(),
        UpdatedAt = table.Column<DateTime>()
    },
    constraints: table =>
    {
        table.PrimaryKey("PK_MetadataLocalizationValues", x => new { x.Key, x.Language });
    });
```

## 性能考虑

1. **索引优化**：复合主键 (Key, Language) 自动创建索引
2. **批量操作**：使用事务批量保存多个语言版本
3. **缓存策略**：利用 `ILocalization` 的缓存机制
4. **懒加载**：前端组件只在初始化时加载语言列表一次

## 未来扩展

1. **语言回退机制**：如果某语言缺失，自动回退到默认语言
2. **翻译审核**：添加翻译状态字段（草稿、已审核）
3. **版本管理**：记录翻译的历史版本
4. **自动翻译**：集成机器翻译 API
5. **翻译复用**：相似文本的翻译建议

## 总结

元数据多语机制通过动态的数据库设计和 Dictionary 结构，实现了完全可扩展的多语言支持。该机制避免了硬编码语言列表，符合开闭原则（OCP），为 BobCRM 系统的国际化提供了灵活而强大的基础设施。

---

**相关文档**：
- [I18N-01-多语机制设计文档](./I18N-01-多语机制设计文档.md)
- [ARCH-01-实体自定义与发布系统设计文档](./ARCH-01-实体自定义与发布系统设计文档.md)
