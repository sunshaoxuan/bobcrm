# I18N-02 元数据多语机制设计文档
## 概述
元数据多语机制是 BobCRM 中用于管理实体定义和字段元数据的国际化支持。该机制与 UI 资源多语（I18N-01）独立，专门处理实体和字段的显示名称及描述的多语言翻译。
**核心设计**：采用 **Map/Json 逻辑类型** 存储多语言元数据，确保元数据模型在逻辑层面的简洁性与灵活性，物理层面则由特定的数据库 Provider 负责实现。
## 设计原则
1. **架构解耦**：利用逻辑 Map 类型存储，屏蔽物理数据库实现细节。
2. **动态动态支持**：在逻辑层面不硬编码语言列表，支持任意语言 Key。
3. **统一元数据模型**：元数据与业务数据采用一致的逻辑多语抽象模型。
4. **扩展性**：支持在不变更物理 Schema 的情况下动态扩展语言。
## 架构设计
### 1. 逻辑模型设计 (Logical Schema)

元数据管理表的模型设计基于逻辑关系，物理映射由 Provider 负责。

#### 1.1 EntityDefinitions - 实体定义表
| 逻辑字段 | 逻辑类型 | 说明 |
| :--- | :--- | :--- |
| Id | GUID | 逻辑主键 |
| Namespace | String | 命名空间 |
| EntityName | String | 实体名 |
| DisplayName | **Map<String, String>** | 多语言显示名 |
| Description | **Map<String, String>** | 多语言描述 |
| Status | Enum | 生命周期状态 |

#### 1.2 FieldMetadata - 字段元数据表
| 逻辑字段 | 逻辑类型 | 说明 |
| :--- | :--- | :--- |
| Id | GUID | 逻辑主键 |
| PropertyName | String | 属性名 |
| DisplayName | **Map<String, String>** | 多语言显示名 |
| DataType | Enum | 数据类型 (String/Int/...) |
| IsRequired | Boolean | 是否必填 |
#### 1.3 逻辑数据格式
统一的多语言逻辑格式：
```json
{
  "ja": "日本語",
  "zh": "中文",
  "en": "English"
}
```
**特点**：
- **键 (Key)**：符合 ISO 规范的语言代码（如 ja, zh, en）。
- **值 (Value)**：该语言对应的翻译文本。
- **抽象性**：不限制物理存储介质（可以是 JSONB, XML, 或 键值对子表）。
### 2. 领域模型
#### 2.1 EntityDefinition 实体
```csharp
using System.ComponentModel.DataAnnotations.Schema;
[Table("EntityDefinitions")]
public class EntityDefinition
{
    public Guid Id { get; set; }
    public string Namespace { get; set; } = string.Empty;
    public string EntityName { get; set; } = string.Empty;
    /// <summary>
    /// 显示名（多语言）- 逻辑 Map 类型
    /// 示例：{"ja": "商品", "zh": "产品", "en": "Product"}
    /// </summary>
    [Column(TypeName = "Map")]
    public Dictionary<string, string>? DisplayName { get; set; }
    /// <summary>
    /// 描述（多语言）- 逻辑 Map 类型
    /// </summary>
    [Column(TypeName = "Map")]
    public Dictionary<string, string>? Description { get; set; }
    // 其他属性...
}
```
#### 2.2 FieldMetadata 实体
```csharp
[Table("FieldMetadata")]
public class FieldMetadata
{
    public Guid Id { get; set; }
    public Guid EntityDefinitionId { get; set; }
    public string PropertyName { get; set; } = string.Empty;
    /// <summary>
    /// 显示名（多语言）- 逻辑 Map 类型
    /// 示例：{"ja": "価格", "zh": "价格", "en": "Price"}
    /// </summary>
    [Column(TypeName = "Map")]
    public Dictionary<string, string>? DisplayName { get; set; }
    // 其他属性...
}
```
#### 2.3 多语言文本 DTO（前端使用）
```csharp
/// <summary>
/// 多语言文本DTO - 使用 Dictionary 动态支持任意语言
/// 继承自 Dictionary 以支持灵活的序列化/反序列化
/// </summary>
public class MultilingualTextDto : Dictionary<string, string?>
{
    public MultilingualTextDto() : base(StringComparer.OrdinalIgnoreCase) { }
    public MultilingualTextDto(Dictionary<string, string>? source)
        : base(StringComparer.OrdinalIgnoreCase)
    {
        if (source != null)
        {
            foreach (var kvp in source)
                this[kvp.Key] = kvp.Value;
        }
    }
    public bool HasValue() =>
        this.Values.Any(v => !string.IsNullOrWhiteSpace(v));
    public string? GetValue(string lang) =>
        TryGetValue(lang?.ToLowerInvariant() ?? "ja", out var value) ? value : null;
    public void SetValue(string lang, string? value) =>
        this[lang?.ToLowerInvariant() ?? "ja"] = value;
}
```
### 3. EF Core 配置
#### 3.1 AppDbContext 配置
```csharp
public class AppDbContext : DbContext
{
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        // EntityDefinition - Map/Json 映射
        modelBuilder.Entity<EntityDefinition>()
            .Property(e => e.DisplayName);
        modelBuilder.Entity<EntityDefinition>()
            .Property(e => e.Description);
        // FieldMetadata - Map/Json 映射
        modelBuilder.Entity<FieldMetadata>()
            .Property(f => f.DisplayName);
    }
}
```
#### 3.2 自动 Map 映射
Provider 自动将 `Dictionary<string, string>` 映射为底层存储格式。例如在 PostgreSQL 中映射为 `jsonb`：
- **保存**：`Dictionary → JSON → Native Map/Json`
- **查询**：`Native Map/Json → JSON → Dictionary`
无需额外的序列化配置。
### 3. 持久化层映射原则
持久化层应支持根据不同的环境配置自动映射逻辑 Map 到物理类型。例如：
- **PostgreSQL**: 映射为 `jsonb` 型。
- **MySQL**: 映射为 `JSON` 或 `LongText`。
- **SQLite**: 映射为 `TEXT`（并在应用层处理序列化）。
### 4. API 端点
#### 4.1 创建实体定义
**端点**：`POST /api/entity-definitions`
**请求体**：
```json
{
  "namespace": "BobCrm.Base.Custom",
  "entityName": "Product",
  "displayName": {
    "ja": "商品",
    "zh": "产品",
    "en": "Product",
    "ko": "제품"
  },
  "description": {
    "ja": "商品情報を管理します",
    "zh": "管理产品信息",
    "en": "Manage product information"
  },
  "fields": [
    {
      "propertyName": "Price",
      "displayName": {
        "ja": "価格",
        "zh": "价格",
        "en": "Price"
      },
      "dataType": "Decimal"
    }
  ]
}
```
**处理流程（简化版）**：
```csharp
group.MapPost("/", async (CreateEntityDefinitionDto dto, AppDbContext db) =>
{
    // 1. 验证多语言显示名
    if (dto.DisplayName == null || !dto.DisplayName.Any() ||
        !dto.DisplayName.Values.Any(v => !string.IsNullOrWhiteSpace(v)))
    {
        return Results.BadRequest("至少需要提供一种语言的显示名");
    }
    // 2. 创建实体定义（直接保存 Dictionary）
    var definition = new EntityDefinition
    {
        Id = Guid.NewGuid(),
        Namespace = dto.Namespace,
        EntityName = dto.EntityName,
        DisplayName = dto.DisplayName,      // 直接赋值，由 Provider 自动转换
        Description = dto.Description,      // 直接赋值
        // ...
    };
    // 3. 创建字段（直接保存 Dictionary）
    foreach (var fieldDto in dto.Fields)
    {
        var field = new FieldMetadata
        {
            Id = Guid.NewGuid(),
            EntityDefinitionId = definition.Id,
            PropertyName = fieldDto.PropertyName,
            DisplayName = fieldDto.DisplayName,  // 直接赋值，由 Provider 自动转换
            // ...
        };
        definition.Fields.Add(field);
    }
    // 4. 保存到数据库
    db.EntityDefinitions.Add(definition);
    await db.SaveChangesAsync();
    return Results.Created($"/api/entity-definitions/{definition.Id}", definition);
});
```
#### 4.2 获取实体定义
**端点**：`GET /api/entity-definitions/{id}`
**响应体**：
```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "entityName": "Product",
  "displayName": {
    "ja": "商品",
    "zh": "产品",
    "en": "Product"
  },
  "description": {
    "ja": "商品情報を管理します",
    "zh": "管理产品信息"
  },
  "fields": [
    {
      "id": "...",
      "propertyName": "Price",
      "displayName": {
        "ja": "価格",
        "zh": "价格",
        "en": "Price"
      },
      "dataType": "Decimal"
    }
  ]
}
```
**处理流程（简化版）**：
```csharp
group.MapGet("/{id:guid}", async (Guid id, AppDbContext db) =>
{
    var definition = await db.EntityDefinitions
        .Include(ed => ed.Fields.OrderBy(f => f.SortOrder))
        .Include(ed => ed.Interfaces)
        .FirstOrDefaultAsync(ed => ed.Id == id);
    if (definition == null)
        return Results.NotFound();
    // DisplayName 和 Description 自动从物理格式反序列化为 Dictionary
    return Results.Json(new
    {
        definition.Id,
        definition.EntityName,
        definition.DisplayName,     // Dictionary<string, string>
        definition.Description,     // Dictionary<string, string>
        Fields = definition.Fields.Select(f => new
        {
            f.Id,
            f.PropertyName,
            f.DisplayName,          // Dictionary<string, string>
            f.DataType,
            // ...
        })
    });
});
```
#### 4.3 更新实体定义
**端点**：`PUT /api/entity-definitions/{id}`
**请求体**：
```json
{
  "displayName": {
    "ja": "商品（更新）",
    "zh": "产品（更新）",
    "en": "Product (Updated)",
    "ko": "제품 (업데이트)"
  },
  "fields": [...]
}
```
**处理流程（简化版）**：
```csharp
group.MapPut("/{id:guid}", async (Guid id, UpdateEntityDefinitionDto dto, AppDbContext db) =>
{
    var definition = await db.EntityDefinitions
        .Include(ed => ed.Fields)
        .FirstOrDefaultAsync(ed => ed.Id == id);
    if (definition == null)
        return Results.NotFound();
    // 直接更新 jsonb 字段
    if (dto.DisplayName != null && dto.DisplayName.Any())
    {
        definition.DisplayName = dto.DisplayName;  // EF Core 自动更新 jsonb
    }
    if (dto.Description != null && dto.Description.Any())
    {
        definition.Description = dto.Description;
    }
    // 更新字段的多语言
    foreach (var fieldDto in dto.Fields)
    {
        var field = definition.Fields.FirstOrDefault(f => f.Id == fieldDto.Id);
        if (field != null && fieldDto.DisplayName != null)
        {
            field.DisplayName = fieldDto.DisplayName;  // 直接更新
        }
    }
    definition.UpdatedAt = DateTime.UtcNow;
    await db.SaveChangesAsync();
    return Results.Ok(definition);
});
```
### 5. 前端组件
#### 5.1 MultilingualInput 组件
动态多语言输入组件，从 API 获取语言列表：
```razor
<MultilingualInput @bind-Value="@_model.DisplayName" />
```
**特点**：
- 组件初始化时从 `/api/i18n/languages` 获取可用语言
- 动态渲染标签页
- 支持任意数量的语言
- 失败时降级到默认语言（ja, zh, en）
**数据绑定**：
- 输入：`MultilingualTextDto?`（继承自 Dictionary）
- 输出：`MultilingualTextDto?`
- API 返回：`Dictionary<string, string>?`
## 工作流程
### 创建实体定义的完整流程
```
┌─────────────────────────────────────────────────────────┐
│ 1. 用户在前端输入多语言文本                                │
│    - 实体名：Product                                      │
│    - 显示名：{ "ja": "商品", "zh": "产品", "en": "Product" } │
└─────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────┐
│ 2. 前端发送请求到后端 API                                  │
│    POST /api/entity-definitions                          │
│    displayName: Dictionary<string, string?>              │
└─────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────┐
│ 3. 后端验证 Dictionary.Values 是否有非空值                │
└─────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────┐
│ 4. 创建 EntityDefinition 对象                            │
│    DisplayName = dto.DisplayName (Dictionary)            │
│    Description = dto.Description (Dictionary)            │
└─────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────┐
│ 5. EF Core 保存到数据库                                   │
│    Dictionary → JSON 序列化 → PostgreSQL jsonb           │
│    DisplayName: {"ja":"商品","zh":"产品","en":"Product"}  │
└─────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────┐
│ 6. 数据库存储（单表，单行）                               │
│    EntityDefinitions 表：                                │
│    | Id | EntityName | DisplayName (jsonb) | ... |       │
│    | .. | Product    | {"ja":"商品",...}    | ... |       │
└─────────────────────────────────────────────────────────┘
```
### 查询实体定义的流程
```
┌─────────────────────────────────────────────────────────┐
│ 1. 前端请求实体定义                                        │
│    GET /api/entity-definitions/{id}                      │
└─────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────┐
│ 2. EF Core 查询单表（无需 JOIN）                          │
│    SELECT * FROM EntityDefinitions WHERE Id = @id        │
└─────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────┐
│ 3. Npgsql 自动反序列化                                    │
│    PostgreSQL jsonb → JSON → Dictionary<string, string>  │
└─────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────┐
│ 4. API 返回 JSON                                          │
│    {                                                     │
│      "displayName": {"ja":"商品","zh":"产品"},            │
│      "fields": [{"displayName": {...}}, ...]             │
│    }                                                     │
└─────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────┐
│ 5. 前端反序列化为 MultilingualTextDto                     │
│    new MultilingualTextDto(entity.DisplayName)           │
└─────────────────────────────────────────────────────────┘
```
## 添加新语言
### 数据库操作
在 `LocalizationLanguages` 表中添加新语言：
```sql
INSERT INTO LocalizationLanguages (Code, NativeName)
VALUES ('ko', '한국어');
```
### 无需代码或表结构修改
- ✅ jsonb 字段自动支持新的键
- ✅ 前端组件自动从 API 获取最新语言列表
- ✅ 用户界面自动显示新的语言标签页
- ✅ 已有数据自动兼容（jsonb 可以包含不同的键集合）
### 更新已有实体的新语言翻译
```csharp
// 获取实体
var entity = await db.EntityDefinitions.FindAsync(entityId);
// 添加新语言翻译（保留原有语言）
if (entity.DisplayName == null)
    entity.DisplayName = new Dictionary<string, string>();
entity.DisplayName["ko"] = "제품";  // 添加韩语翻译
await db.SaveChangesAsync();
```
---

## 附录：物理实现参考 (Implementation Reference)

### PostgreSQL 实现与优势 (jsonb)

| 特性 | 关系表方案 | jsonb 方案 |
|------|-----------|-----------|
| 表数量 | 需要额外的 MetadataLocalizationValues 表 | 无需额外表 |
| 查询性能 | 需要 JOIN 或循环查询 | 单表查询，性能更好 |
| 存储结构 | 多行（每语言一行）| 单行（所有语言在一个 jsonb） |
| 代码复杂度 | 需要 MetadataI18nService | 无需额外服务 |
| 语言扩展 | 无需改表结构（但需要遍历更新）| 无需改表结构，直接添加键 |
| 索引支持 | 标准 B-tree 索引 | GIN/GiST 索引，支持 jsonb 操作符 |
| 部分更新 | UPDATE 单行 | UPDATE jsonb 字段（可用操作符）|

#### PostgreSQL jsonb 特性
1. **高效存储**：二进制格式，压缩存储
2. **快速查询**：支持 GIN 索引，查询速度快
3. **操作符支持**：`->`, `->>`, `@>`, `?`, `?&`, `?|` 等
4. **部分更新**：`jsonb_set()` 函数
5. **验证约束**：可添加 CHECK 约束验证结构

#### 示例：jsonb 高级查询
```sql
-- 查询包含日语翻译的实体
SELECT * FROM EntityDefinitions
WHERE DisplayName ? 'ja';
-- 查询日语翻译包含"商品"的实体
SELECT * FROM EntityDefinitions
WHERE DisplayName->>'ja' LIKE '%商品%';
-- 更新特定语言的翻译（保留其他语言）
SET DisplayName = jsonb_set(DisplayName, '{ko}', '"제품"')
WHERE EntityName = 'Product';
-- 创建 GIN 索引加速查询
CREATE INDEX idx_entitydefinitions_displayname
ON EntityDefinitions USING GIN (DisplayName);
```
## 与 UI 资源多语的统一
由于采用了 jsonb 方案，元数据多语和业务数据多语现在使用相同的模式：
| 场景 | 数据类型 | 存储方式 |
|------|---------|---------|
| 实体显示名 | Dictionary<string, string>? | EntityDefinitions.DisplayName (jsonb) |
| 字段显示名 | Dictionary<string, string>? | FieldMetadata.DisplayName (jsonb) |
| 业务数据多语 | Dictionary<string, string>? | CustomEntity.FieldName (jsonb) |
| UI 资源多语 | 仍使用固定列（兼容性） | LocalizationResource.JA, ZH, EN |
**未来可选优化**：将 UI 资源多语也改为 jsonb 方案，实现完全统一。
## 最佳实践
### 1. 验证规则
```csharp
// 至少提供一种语言的文本
if (translations == null || !translations.Any() ||
    !translations.Values.Any(v => !string.IsNullOrWhiteSpace(v)))
{
    return Results.BadRequest("至少需要提供一种语言的文本");
}
```
### 2. 默认语言处理
```csharp
// 获取多语言文本，回退到默认语言
public static string? GetLocalizedValue(
    Dictionary<string, string>? multilingual,
    string currentLang,
    string defaultLang = "ja")
{
    if (multilingual == null) return null;
    // 尝试当前语言
    if (multilingual.TryGetValue(currentLang, out var value))
        return value;
    // 回退到默认语言
    if (multilingual.TryGetValue(defaultLang, out var defaultValue))
        return defaultValue;
    // 返回任意第一个非空值
    return multilingual.Values.FirstOrDefault(v => !string.IsNullOrWhiteSpace(v));
}
```
### 3. 空值处理
```csharp
// 创建时检查
if (dto.DisplayName?.Any(kvp => !string.IsNullOrWhiteSpace(kvp.Value)) == true)
{
    entity.DisplayName = dto.DisplayName;
}
else
{
    entity.DisplayName = null;  // 或返回错误
}
```
### 4. EF Core 查询
```csharp
// 查询包含特定语言的实体（使用 EF.Functions）
var entities = await db.EntityDefinitions
    .Where(e => EF.Functions.JsonExists(e.DisplayName, "ja"))
    .ToListAsync();
// 注意：复杂 jsonb 查询可能需要原始 SQL
```
### 4. 迁移路径 (Design Migration)

当需要将现有的扁平结构或其他多语方案迁移到 Map/Json 方案时，遵循以下逻辑步骤：

1. **Schema 演进**：向目标逻辑表添加 Map/Json 类型的复合字段。
2. **数据汇聚**：通过逻辑任务将各语言分表的字段数据归并到同一行复合字段中。
3. **结构修剪**：一旦验证复合字段完整，即可移除原有的单语物理字段。
## 性能考虑
1. **索引策略**：
   - 对常查询的 jsonb 列创建 GIN 索引
   - 索引大小：jsonb GIN 索引比 B-tree 大，但查询更快
2. **查询优化**：
   - 单表查询，无需 JOIN，性能优于关系表方案
   - 使用 `->` 和 `->>` 操作符提取 jsonb 值
   - 避免在 WHERE 子句中对整个 jsonb 进行操作
3. **存储空间**：
   - jsonb 二进制格式，比 json 更高效
   - 对于多语言字段，jsonb 比多行关系表更节省空间
4. **缓存策略**：
   - 实体定义通常不频繁修改，可在应用层缓存
   - 利用 EF Core 的查询缓存
## 未来扩展
1. **语言回退链**：ja → en → 第一个非空值
2. **翻译覆盖率统计**：分析哪些实体缺少特定语言翻译
3. **批量翻译导入/导出**：支持 CSV/Excel 批量管理翻译
4. **自动翻译建议**：集成机器翻译 API
5. **翻译版本管理**：记录翻译的修改历史（可用 jsonb 数组）
6. **全文搜索**：使用 PostgreSQL 全文搜索索引多语言内容
## 总结
通过使用 **Map/Json 逻辑类型**，元数据多语机制实现了：
✅ **架构简化**：无需额外的关系表和中间服务
✅ **性能提升**：单表查询，性能远超传统关联方案
✅ **代码简洁**：Provider 自动处理序列化/反序列化
✅ **完全动态**：支持任意语言，无需修改表结构
✅ **统一模型**：业务数据多语和元数据多语使用相同方案
✅ **灵活适配**：利用不同数据库的最佳原生支持（如 JSONB/JSON）
该方案符合"简洁高效"的设计原则，为 BobCRM 系统提供了可扩展且高性能的多语言支持。
---
**相关文档**：
- [I18N-01-多语机制设计文档](./I18N-01-多语机制设计文档.md)
- [ARCH-01-实体自定义与发布系统设计文档](./ARCH-01-实体自定义与发布系统设计文档.md)
