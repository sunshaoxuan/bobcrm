# I18N-02 元数据多语机制设计文档
## 概述
元数据多语机制是 BobCRM 中用于管理实体定义和字段元数据的国际化支持。该机制与 UI 资源多语（I18N-01）独立，专门处理实体和字段的显示名称及描述的多语言翻译。
**核心设计**：直接使用 PostgreSQL 的 `jsonb` 类型存储多语言数据，无需额外的关系表和中间服务。
## 设计原则
1. **简洁高效**：利用 PostgreSQL jsonb 存储，无需额外表和 JOIN
2. **动态语言支持**：不硬编码语言列表，jsonb 支持任意语言键值对
3. **统一数据模型**：业务数据多语和元数据多语使用相同的 jsonb 模式
4. **可扩展性**：添加新语言无需修改表结构或代码
5. **性能优化**：单表查询，支持 jsonb 索引和操作符
## 架构设计
### 1. 数据库表结构
#### 1.1 EntityDefinitions 表
```sql
CREATE TABLE EntityDefinitions (
    Id UUID PRIMARY KEY,
    Namespace VARCHAR(256) NOT NULL,
    EntityName VARCHAR(100) NOT NULL,
    FullTypeName VARCHAR(512) NOT NULL,
    -- 多语言字段（jsonb 格式）
    DisplayName JSONB,              -- {"ja": "商品", "zh": "产品", "en": "Product"}
    Description JSONB,              -- {"ja": "商品情報", "zh": "产品信息", "en": "Product info"}
    -- 其他字段
    ApiEndpoint VARCHAR(256),
    StructureType VARCHAR(50),
    Status VARCHAR(50),
    -- ...
);
```
#### 1.2 FieldMetadata 表
```sql
CREATE TABLE FieldMetadata (
    Id UUID PRIMARY KEY,
    EntityDefinitionId UUID NOT NULL,
    PropertyName VARCHAR(100) NOT NULL,
    -- 多语言字段（jsonb 格式）
    DisplayName JSONB,              -- {"ja": "価格", "zh": "价格", "en": "Price"}
    -- 其他字段
    DataType VARCHAR(50),
    Length INT,
    IsRequired BOOLEAN,
    -- ...
);
```
#### 1.3 jsonb 数据格式
统一的多语言 JSON 格式：
```json
{
  "ja": "日本語値",
  "zh": "中文值",
  "en": "English Value",
  "ko": "한국어 값",
  "fr": "Valeur française"
}
```
**特点**：
- 键：语言代码（小写，如 ja, zh, en, ko）
- 值：该语言的文本
- 支持任意数量的语言
- 可为空（整个 jsonb 列可为 null）
### 2. 领域模型
#### 2.1 EntityDefinition 实体
```csharp
using System.ComponentModel.DataAnnotations.Schema;
[Table("EntityDefinitions")]
public class EntityDefinition
{
    public Guid Id { get; set; }
    public string Namespace { get; set; } = string.Empty;
    public string EntityName { get; set; } = string.Empty;
    /// <summary>
    /// 显示名（多语言）- PostgreSQL jsonb 类型
    /// 示例：{"ja": "商品", "zh": "产品", "en": "Product"}
    /// </summary>
    [Column(TypeName = "jsonb")]
    public Dictionary<string, string>? DisplayName { get; set; }
    /// <summary>
    /// 描述（多语言）- PostgreSQL jsonb 类型
    /// </summary>
    [Column(TypeName = "jsonb")]
    public Dictionary<string, string>? Description { get; set; }
    // 其他属性...
}
```
#### 2.2 FieldMetadata 实体
```csharp
[Table("FieldMetadata")]
public class FieldMetadata
{
    public Guid Id { get; set; }
    public Guid EntityDefinitionId { get; set; }
    public string PropertyName { get; set; } = string.Empty;
    /// <summary>
    /// 显示名（多语言）- PostgreSQL jsonb 类型
    /// 示例：{"ja": "価格", "zh": "价格", "en": "Price"}
    /// </summary>
    [Column(TypeName = "jsonb")]
    public Dictionary<string, string>? DisplayName { get; set; }
    // 其他属性...
}
```
#### 2.3 多语言文本 DTO（前端使用）
```csharp
/// <summary>
/// 多语言文本DTO - 使用 Dictionary 动态支持任意语言
/// 继承自 Dictionary 以支持灵活的序列化/反序列化
/// </summary>
public class MultilingualTextDto : Dictionary<string, string?>
{
    public MultilingualTextDto() : base(StringComparer.OrdinalIgnoreCase) { }
    public MultilingualTextDto(Dictionary<string, string>? source)
        : base(StringComparer.OrdinalIgnoreCase)
    {
        if (source != null)
        {
            foreach (var kvp in source)
                this[kvp.Key] = kvp.Value;
        }
    }
    public bool HasValue() =>
        this.Values.Any(v => !string.IsNullOrWhiteSpace(v));
    public string? GetValue(string lang) =>
        TryGetValue(lang?.ToLowerInvariant() ?? "ja", out var value) ? value : null;
    public void SetValue(string lang, string? value) =>
        this[lang?.ToLowerInvariant() ?? "ja"] = value;
}
```
### 3. EF Core 配置
#### 3.1 AppDbContext 配置
```csharp
public class AppDbContext : DbContext
{
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        // EntityDefinition - jsonb 映射
        modelBuilder.Entity<EntityDefinition>()
            .Property(e => e.DisplayName)
            .HasColumnType("jsonb");
        modelBuilder.Entity<EntityDefinition>()
            .Property(e => e.Description)
            .HasColumnType("jsonb");
        // FieldMetadata - jsonb 映射
        modelBuilder.Entity<FieldMetadata>()
            .Property(f => f.DisplayName)
            .HasColumnType("jsonb");
    }
}
```
#### 3.2 Npgsql 自动 JSON 映射
Npgsql 自动将 `Dictionary<string, string>` 映射为 jsonb：
- **保存**：`Dictionary → JSON → jsonb`
- **查询**：`jsonb → JSON → Dictionary`
无需额外的序列化配置。
### 4. API 端点
#### 4.1 创建实体定义
**端点**：`POST /api/entity-definitions`
**请求体**：
```json
{
  "namespace": "BobCrm.Base.Custom",
  "entityName": "Product",
  "displayName": {
    "ja": "商品",
    "zh": "产品",
    "en": "Product",
    "ko": "제품"
  },
  "description": {
    "ja": "商品情報を管理します",
    "zh": "管理产品信息",
    "en": "Manage product information"
  },
  "fields": [
    {
      "propertyName": "Price",
      "displayName": {
        "ja": "価格",
        "zh": "价格",
        "en": "Price"
      },
      "dataType": "Decimal"
    }
  ]
}
```
**处理流程（简化版）**：
```csharp
group.MapPost("/", async (CreateEntityDefinitionDto dto, AppDbContext db) =>
{
    // 1. 验证多语言显示名
    if (dto.DisplayName == null || !dto.DisplayName.Any() ||
        !dto.DisplayName.Values.Any(v => !string.IsNullOrWhiteSpace(v)))
    {
        return Results.BadRequest("至少需要提供一种语言的显示名");
    }
    // 2. 创建实体定义（直接保存 Dictionary）
    var definition = new EntityDefinition
    {
        Id = Guid.NewGuid(),
        Namespace = dto.Namespace,
        EntityName = dto.EntityName,
        DisplayName = dto.DisplayName,      // 直接赋值，EF Core 自动转 jsonb
        Description = dto.Description,      // 直接赋值
        // ...
    };
    // 3. 创建字段（直接保存 Dictionary）
    foreach (var fieldDto in dto.Fields)
    {
        var field = new FieldMetadata
        {
            Id = Guid.NewGuid(),
            EntityDefinitionId = definition.Id,
            PropertyName = fieldDto.PropertyName,
            DisplayName = fieldDto.DisplayName,  // 直接赋值，EF Core 自动转 jsonb
            // ...
        };
        definition.Fields.Add(field);
    }
    // 4. 保存到数据库
    db.EntityDefinitions.Add(definition);
    await db.SaveChangesAsync();
    return Results.Created($"/api/entity-definitions/{definition.Id}", definition);
});
```
#### 4.2 获取实体定义
**端点**：`GET /api/entity-definitions/{id}`
**响应体**：
```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "entityName": "Product",
  "displayName": {
    "ja": "商品",
    "zh": "产品",
    "en": "Product"
  },
  "description": {
    "ja": "商品情報を管理します",
    "zh": "管理产品信息"
  },
  "fields": [
    {
      "id": "...",
      "propertyName": "Price",
      "displayName": {
        "ja": "価格",
        "zh": "价格",
        "en": "Price"
      },
      "dataType": "Decimal"
    }
  ]
}
```
**处理流程（简化版）**：
```csharp
group.MapGet("/{id:guid}", async (Guid id, AppDbContext db) =>
{
    var definition = await db.EntityDefinitions
        .Include(ed => ed.Fields.OrderBy(f => f.SortOrder))
        .Include(ed => ed.Interfaces)
        .FirstOrDefaultAsync(ed => ed.Id == id);
    if (definition == null)
        return Results.NotFound();
    // DisplayName 和 Description 自动从 jsonb 反序列化为 Dictionary
    return Results.Json(new
    {
        definition.Id,
        definition.EntityName,
        definition.DisplayName,     // Dictionary<string, string>
        definition.Description,     // Dictionary<string, string>
        Fields = definition.Fields.Select(f => new
        {
            f.Id,
            f.PropertyName,
            f.DisplayName,          // Dictionary<string, string>
            f.DataType,
            // ...
        })
    });
});
```
#### 4.3 更新实体定义
**端点**：`PUT /api/entity-definitions/{id}`
**请求体**：
```json
{
  "displayName": {
    "ja": "商品（更新）",
    "zh": "产品（更新）",
    "en": "Product (Updated)",
    "ko": "제품 (업데이트)"
  },
  "fields": [...]
}
```
**处理流程（简化版）**：
```csharp
group.MapPut("/{id:guid}", async (Guid id, UpdateEntityDefinitionDto dto, AppDbContext db) =>
{
    var definition = await db.EntityDefinitions
        .Include(ed => ed.Fields)
        .FirstOrDefaultAsync(ed => ed.Id == id);
    if (definition == null)
        return Results.NotFound();
    // 直接更新 jsonb 字段
    if (dto.DisplayName != null && dto.DisplayName.Any())
    {
        definition.DisplayName = dto.DisplayName;  // EF Core 自动更新 jsonb
    }
    if (dto.Description != null && dto.Description.Any())
    {
        definition.Description = dto.Description;
    }
    // 更新字段的多语言
    foreach (var fieldDto in dto.Fields)
    {
        var field = definition.Fields.FirstOrDefault(f => f.Id == fieldDto.Id);
        if (field != null && fieldDto.DisplayName != null)
        {
            field.DisplayName = fieldDto.DisplayName;  // EF Core 自动更新 jsonb
        }
    }
    definition.UpdatedAt = DateTime.UtcNow;
    await db.SaveChangesAsync();
    return Results.Ok(definition);
});
```
### 5. 前端组件
#### 5.1 MultilingualInput 组件
动态多语言输入组件，从 API 获取语言列表：
```razor
<MultilingualInput @bind-Value="@_model.DisplayName" />
```
**特点**：
- 组件初始化时从 `/api/i18n/languages` 获取可用语言
- 动态渲染标签页
- 支持任意数量的语言
- 失败时降级到默认语言（ja, zh, en）
**数据绑定**：
- 输入：`MultilingualTextDto?`（继承自 Dictionary）
- 输出：`MultilingualTextDto?`
- API 返回：`Dictionary<string, string>?`
## 工作流程
### 创建实体定义的完整流程
```
┌─────────────────────────────────────────────────────────┐
│ 1. 用户在前端输入多语言文本                                │
│    - 实体名：Product                                      │
│    - 显示名：{ "ja": "商品", "zh": "产品", "en": "Product" } │
└─────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────┐
│ 2. 前端发送请求到后端 API                                  │
│    POST /api/entity-definitions                          │
│    displayName: Dictionary<string, string?>              │
└─────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────┐
│ 3. 后端验证 Dictionary.Values 是否有非空值                │
└─────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────┐
│ 4. 创建 EntityDefinition 对象                            │
│    DisplayName = dto.DisplayName (Dictionary)            │
│    Description = dto.Description (Dictionary)            │
└─────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────┐
│ 5. EF Core 保存到数据库                                   │
│    Dictionary → JSON 序列化 → PostgreSQL jsonb           │
│    DisplayName: {"ja":"商品","zh":"产品","en":"Product"}  │
└─────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────┐
│ 6. 数据库存储（单表，单行）                               │
│    EntityDefinitions 表：                                │
│    | Id | EntityName | DisplayName (jsonb) | ... |       │
│    | .. | Product    | {"ja":"商品",...}    | ... |       │
└─────────────────────────────────────────────────────────┘
```
### 查询实体定义的流程
```
┌─────────────────────────────────────────────────────────┐
│ 1. 前端请求实体定义                                        │
│    GET /api/entity-definitions/{id}                      │
└─────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────┐
│ 2. EF Core 查询单表（无需 JOIN）                          │
│    SELECT * FROM EntityDefinitions WHERE Id = @id        │
└─────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────┐
│ 3. Npgsql 自动反序列化                                    │
│    PostgreSQL jsonb → JSON → Dictionary<string, string>  │
└─────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────┐
│ 4. API 返回 JSON                                          │
│    {                                                     │
│      "displayName": {"ja":"商品","zh":"产品"},            │
│      "fields": [{"displayName": {...}}, ...]             │
│    }                                                     │
└─────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────┐
│ 5. 前端反序列化为 MultilingualTextDto                     │
│    new MultilingualTextDto(entity.DisplayName)           │
└─────────────────────────────────────────────────────────┘
```
## 添加新语言
### 数据库操作
在 `LocalizationLanguages` 表中添加新语言：
```sql
INSERT INTO LocalizationLanguages (Code, NativeName)
VALUES ('ko', '한국어');
```
### 无需代码或表结构修改
- ✅ jsonb 字段自动支持新的键
- ✅ 前端组件自动从 API 获取最新语言列表
- ✅ 用户界面自动显示新的语言标签页
- ✅ 已有数据自动兼容（jsonb 可以包含不同的键集合）
### 更新已有实体的新语言翻译
```csharp
// 获取实体
var entity = await db.EntityDefinitions.FindAsync(entityId);
// 添加新语言翻译（保留原有语言）
if (entity.DisplayName == null)
    entity.DisplayName = new Dictionary<string, string>();
entity.DisplayName["ko"] = "제품";  // 添加韩语翻译
await db.SaveChangesAsync();
```
## jsonb 优势
### 与关系表方案对比
| 特性 | 关系表方案 | jsonb 方案 |
|------|-----------|-----------|
| 表数量 | 需要额外的 MetadataLocalizationValues 表 | 无需额外表 |
| 查询性能 | 需要 JOIN 或循环查询 | 单表查询，性能更好 |
| 存储结构 | 多行（每语言一行）| 单行（所有语言在一个 jsonb） |
| 代码复杂度 | 需要 MetadataI18nService | 无需额外服务 |
| 语言扩展 | 无需改表结构（但需要遍历更新）| 无需改表结构，直接添加键 |
| 索引支持 | 标准 B-tree 索引 | GIN/GiST 索引，支持 jsonb 操作符 |
| 部分更新 | UPDATE 单行 | UPDATE jsonb 字段（可用操作符）|
### PostgreSQL jsonb 特性
1. **高效存储**：二进制格式，压缩存储
2. **快速查询**：支持 GIN 索引，查询速度快
3. **操作符支持**：`->`, `->>`, `@>`, `?`, `?&`, `?|` 等
4. **部分更新**：`jsonb_set()` 函数
5. **验证约束**：可添加 CHECK 约束验证结构
### 示例：jsonb 高级查询
```sql
-- 查询包含日语翻译的实体
SELECT * FROM EntityDefinitions
WHERE DisplayName ? 'ja';
-- 查询日语翻译包含"商品"的实体
SELECT * FROM EntityDefinitions
WHERE DisplayName->>'ja' LIKE '%商品%';
-- 更新特定语言的翻译（保留其他语言）
UPDATE EntityDefinitions
SET DisplayName = jsonb_set(DisplayName, '{ko}', '"제품"')
WHERE EntityName = 'Product';
-- 创建 GIN 索引加速查询
CREATE INDEX idx_entitydefinitions_displayname
ON EntityDefinitions USING GIN (DisplayName);
```
## 与 UI 资源多语的统一
由于采用了 jsonb 方案，元数据多语和业务数据多语现在使用相同的模式：
| 场景 | 数据类型 | 存储方式 |
|------|---------|---------|
| 实体显示名 | Dictionary<string, string>? | EntityDefinitions.DisplayName (jsonb) |
| 字段显示名 | Dictionary<string, string>? | FieldMetadata.DisplayName (jsonb) |
| 业务数据多语 | Dictionary<string, string>? | CustomEntity.FieldName (jsonb) |
| UI 资源多语 | 仍使用固定列（兼容性） | LocalizationResource.JA, ZH, EN |
**未来可选优化**：将 UI 资源多语也改为 jsonb 方案，实现完全统一。
## 最佳实践
### 1. 验证规则
```csharp
// 至少提供一种语言的文本
if (translations == null || !translations.Any() ||
    !translations.Values.Any(v => !string.IsNullOrWhiteSpace(v)))
{
    return Results.BadRequest("至少需要提供一种语言的文本");
}
```
### 2. 默认语言处理
```csharp
// 获取多语言文本，回退到默认语言
public static string? GetLocalizedValue(
    Dictionary<string, string>? multilingual,
    string currentLang,
    string defaultLang = "ja")
{
    if (multilingual == null) return null;
    // 尝试当前语言
    if (multilingual.TryGetValue(currentLang, out var value))
        return value;
    // 回退到默认语言
    if (multilingual.TryGetValue(defaultLang, out var defaultValue))
        return defaultValue;
    // 返回任意第一个非空值
    return multilingual.Values.FirstOrDefault(v => !string.IsNullOrWhiteSpace(v));
}
```
### 3. 空值处理
```csharp
// 创建时检查
if (dto.DisplayName?.Any(kvp => !string.IsNullOrWhiteSpace(kvp.Value)) == true)
{
    entity.DisplayName = dto.DisplayName;
}
else
{
    entity.DisplayName = null;  // 或返回错误
}
```
### 4. EF Core 查询
```csharp
// 查询包含特定语言的实体（使用 EF.Functions）
var entities = await db.EntityDefinitions
    .Where(e => EF.Functions.JsonExists(e.DisplayName, "ja"))
    .ToListAsync();
// 注意：复杂 jsonb 查询可能需要原始 SQL
```
## 数据库迁移
### 创建迁移
```bash
# 删除旧的迁移（如果有 MetadataLocalizationValues 相关）
dotnet ef migrations remove
# 创建新迁移
dotnet ef migrations add RefactorToJsonbMultilingual
# 应用迁移
dotnet ef database update
```
### 迁移内容
```csharp
public partial class RefactorToJsonbMultilingual : Migration
{
    protected override void Up(MigrationBuilder migrationBuilder)
    {
        // 如果存在旧的 MetadataLocalizationValues 表，删除它
        migrationBuilder.DropTable(
            name: "MetadataLocalizationValues");
        // EntityDefinitions 表 - 删除 Key 列，添加 jsonb 列
        migrationBuilder.DropColumn(
            name: "DisplayNameKey",
            table: "EntityDefinitions");
        migrationBuilder.DropColumn(
            name: "DescriptionKey",
            table: "EntityDefinitions");
        migrationBuilder.AddColumn<Dictionary<string, string>>(
            name: "DisplayName",
            table: "EntityDefinitions",
            type: "jsonb",
            nullable: true);
        migrationBuilder.AddColumn<Dictionary<string, string>>(
            name: "Description",
            table: "EntityDefinitions",
            type: "jsonb",
            nullable: true);
        // FieldMetadata 表 - 删除 Key 列，添加 jsonb 列
        migrationBuilder.DropColumn(
            name: "DisplayNameKey",
            table: "FieldMetadata");
        migrationBuilder.AddColumn<Dictionary<string, string>>(
            name: "DisplayName",
            table: "FieldMetadata",
            type: "jsonb",
            nullable: true);
        // 创建 GIN 索引（可选，提升查询性能）
        migrationBuilder.Sql(@"
            CREATE INDEX idx_entitydefinitions_displayname
            ON ""EntityDefinitions"" USING GIN (""DisplayName"");
            CREATE INDEX idx_fieldmetadata_displayname
            ON ""FieldMetadata"" USING GIN (""DisplayName"");
        ");
    }
    protected override void Down(MigrationBuilder migrationBuilder)
    {
        // 回滚操作（重建旧结构）
        migrationBuilder.DropColumn(name: "DisplayName", table: "EntityDefinitions");
        migrationBuilder.DropColumn(name: "Description", table: "EntityDefinitions");
        migrationBuilder.DropColumn(name: "DisplayName", table: "FieldMetadata");
        migrationBuilder.AddColumn<string>(
            name: "DisplayNameKey",
            table: "EntityDefinitions",
            maxLength: 256);
        // ...
    }
}
```
## 性能考虑
1. **索引策略**：
   - 对常查询的 jsonb 列创建 GIN 索引
   - 索引大小：jsonb GIN 索引比 B-tree 大，但查询更快
2. **查询优化**：
   - 单表查询，无需 JOIN，性能优于关系表方案
   - 使用 `->` 和 `->>` 操作符提取 jsonb 值
   - 避免在 WHERE 子句中对整个 jsonb 进行操作
3. **存储空间**：
   - jsonb 二进制格式，比 json 更高效
   - 对于多语言字段，jsonb 比多行关系表更节省空间
4. **缓存策略**：
   - 实体定义通常不频繁修改，可在应用层缓存
   - 利用 EF Core 的查询缓存
## 未来扩展
1. **语言回退链**：ja → en → 第一个非空值
2. **翻译覆盖率统计**：分析哪些实体缺少特定语言翻译
3. **批量翻译导入/导出**：支持 CSV/Excel 批量管理翻译
4. **自动翻译建议**：集成机器翻译 API
5. **翻译版本管理**：记录翻译的修改历史（可用 jsonb 数组）
6. **全文搜索**：使用 PostgreSQL 全文搜索索引多语言内容
## 总结
通过使用 PostgreSQL 的 jsonb 类型，元数据多语机制实现了：
✅ **架构简化**：无需额外的关系表和中间服务
✅ **性能提升**：单表查询，无需 JOIN
✅ **代码简洁**：EF Core 自动序列化/反序列化
✅ **完全动态**：支持任意语言，无需修改表结构
✅ **统一模型**：业务数据多语和元数据多语使用相同方案
✅ **原生支持**：利用 PostgreSQL 的强大 jsonb 功能
该方案符合"简洁高效"的设计原则，为 BobCRM 系统提供了可扩展且高性能的多语言支持。
---
**相关文档**：
- [I18N-01-多语机制设计文档](./I18N-01-多语机制设计文档.md)
- [ARCH-01-实体自定义与发布系统设计文档](./ARCH-01-实体自定义与发布系统设计文档.md)
