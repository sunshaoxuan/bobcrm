# BobCRM 多语机制设计文档

## 概述

BobCRM 实现了两种独立的多语机制：

1. **UI 资源多语**：用于界面文本（按钮、标签、提示等）
2. **数据多语**：用于业务实体的属性（如客户名称、产品描述等）

## 1. UI 资源多语

### 实现方式

- **存储表**：`LocalizationResource`
- **字段**：`Key` (主键), `ZH`, `JA`, `EN`
- **使用**：前端通过 `I18nService.T("KEY")` 获取翻译

### 示例

```csharp
// 数据库中存储
{
  "Key": "BTN_LOGOUT",
  "ZH": "退出",
  "JA": "ログアウト",
  "EN": "Logout"
}

// 前端使用
<button>@I18n.T("BTN_LOGOUT")</button>
```

### 缓存与版本（新增，v0.3）

- 服务端缓存：`ILocalization` 采用 `IMemoryCache` + 版本号（Ticks）
  - 生命周期：Singleton；跨请求共享缓存
  - 方法：`InvalidateCache()` 清除所有语言缓存并更新版本；`GetCacheVersion()` 返回当前版本（供 ETag）
- 端点契约：
  - `GET /api/i18n/version` → `{ version }`
  - `GET /api/i18n/{lang}` 返回字典，并设置 `ETag: "{version}_{lang}"` 与 `Cache-Control: public, max-age=1800`
  - 客户端携带 `If-None-Match` 命中时返回 304，减少流量
- 客户端缓存：
  - `I18nService` 先读 localStorage 缓存 `{ lang, version, dict }`；若版本一致则跳过拉取
  - 语言切换时更新 `X-Lang` 请求头与 cookie，并触发 `OnChanged`

### 平台约束（统一行为）

- 客户端必须在获取词典时携带 `If-None-Match`，命中服务端版本返回 304；
- 词典唯一来源为 `/api/i18n/{lang}`；页面/组件内禁止硬编码文本，全部通过 `I18nService.T("KEY")` 获取；
- 语言切换只更新一个全局来源（`I18nService`），并通过 `OnChanged` 触发页面刷新，禁止页面自行缓存词典副本；
- 服务端负责版本一致性（`GetCacheVersion()`）与失效通知（`InvalidateCache()`），前端不维护版本号；
- 词典在 localStorage 的键采用固定命名（`bobcrm.i18n.{lang}`），结构 `{ lang, version, dict }`，禁止私有变体；

### 词条预置与冷启动

- 启动初始化：
  - 种子插入常用词条（认证/菜单/按钮/设计器核心文本），避免冷启动空白；
  - 支持从 CSV/JSON 导入预置词条，统一入口（管理员） `/api/admin/i18n/import`（后续）；
- 缺失兜底：
  - 前端 `T(key)` 在找不到词条时返回 `key` 本身，并记录一次警告日志（去抖动）；
  - 服务端端点提供检查缺失词条的诊断接口（后续）。

## 2. 数据多语

### 实现方式

使用**分表存储**的模式，为每个需要本地化的实体创建对应的 `{Entity}Localization` 表。

### 架构设计

#### 2.1 接口定义

```csharp
// 本地化数据必须实现的接口
public interface ILocalizationData
{
    int EntityId { get; set; }
    string Language { get; set; }
    string? GetLocalizedValue(string propertyName);
}
```

#### 2.2 特性标记

使用 `[Localizable]` 特性标记需要本地化的属性：

```csharp
public class Customer
{
    public int Id { get; set; }
    public string Code { get; set; } = string.Empty;
    
    [Localizable(Required = false, MaxLength = 256, Hint = "客户名称")]
    public string Name { get; set; } = string.Empty;
}
```

#### 2.3 本地化实体

创建 `CustomerLocalization` 表存储多语言数据：

```csharp
public class CustomerLocalization : ILocalizationData
{
    [Key]
    public int CustomerId { get; set; }
    
    [Key]
    public string Language { get; set; } = string.Empty;
    
    public string? Name { get; set; }
    
    // ILocalizationData 实现
    public int EntityId { get => CustomerId; set => CustomerId = value; }
    
    public string? GetLocalizedValue(string propertyName)
    {
        return propertyName switch
        {
            nameof(Name) => Name,
            _ => null
        };
    }
}
```

#### 2.4 查询逻辑

在查询时根据当前语言返回本地化值：

```csharp
public List<object> GetList()
{
    var lang = LangHelper.GetLang(_http.HttpContext!);
    
    // 尝试获取本地化名称
    Dictionary<int, string?> localizedNames = new();
    try
    {
        localizedNames = _repoLocalization.Query()
            .Where(l => l.Language == lang)
            .ToDictionary(l => l.CustomerId, l => l.Name);
    }
    catch
    {
        // 表不存在时使用默认名称
    }
    
    return customers.Select(c => new 
    { 
        id = c.Id, 
        code = c.Code, 
        name = localizedNames.ContainsKey(c.Id) && !string.IsNullOrEmpty(localizedNames[c.Id])
            ? localizedNames[c.Id]
            : c.Name 
    }).ToList();
}
```

### 添加新实体的多语支持

假设要为 `Product` 实体添加多语支持：

#### 步骤 1：标记可本地化属性

```csharp
public class Product
{
    public int Id { get; set; }
    
    [Localizable(Required = false, MaxLength = 256)]
    public string Name { get; set; } = string.Empty;
    
    [Localizable(Required = false, MaxLength = 1000)]
    public string? Description { get; set; }
}
```

#### 步骤 2：创建本地化实体

```csharp
public class ProductLocalization : ILocalizationData
{
    [Key, Column(Order = 0)]
    public int ProductId { get; set; }
    
    [Key, Column(Order = 1), MaxLength(8)]
    public string Language { get; set; } = string.Empty;
    
    [MaxLength(256)]
    public string? Name { get; set; }
    
    [MaxLength(1000)]
    public string? Description { get; set; }
    
    [ForeignKey("ProductId")]
    public Product? Product { get; set; }
    
    // ILocalizationData 实现
    public int EntityId { get => ProductId; set => ProductId = value; }
    
    public string? GetLocalizedValue(string propertyName)
    {
        return propertyName switch
        {
            nameof(Name) => Name,
            nameof(Description) => Description,
            _ => null
        };
    }
}
```

#### 步骤 3：添加到 DbContext

```csharp
public DbSet<ProductLocalization> ProductLocalizations => Set<ProductLocalization>();
```

#### 步骤 4：创建配置

```csharp
public class ProductLocalizationConfiguration : IEntityTypeConfiguration<ProductLocalization>
{
    public void Configure(EntityTypeBuilder<ProductLocalization> builder)
    {
        builder.HasKey(x => new { x.ProductId, x.Language });
        builder.HasOne(x => x.Product)
            .WithMany()
            .HasForeignKey(x => x.ProductId)
            .OnDelete(DeleteBehavior.Cascade);
    }
}
```

#### 步骤 5：更新查询逻辑

在 `ProductQueries` 中根据语言返回本地化值，类似于 `CustomerQueries`。

#### 步骤 6：初始化数据

在 `DatabaseInitializer` 中为测试数据添加多语言版本。

## 优势

1. **关注点分离**：UI 文本和业务数据分开处理
2. **易于扩展**：为任意实体添加多语支持只需遵循约定
3. **类型安全**：通过接口约束保证一致性
4. **容错处理**：表不存在时自动回退到默认值
5. **性能优化**：只查询需要的语言数据

## 约定

1. **命名**：本地化实体命名为 `{Entity}Localization`
2. **主键**：使用复合主键 `(EntityId, Language)`
3. **外键**：引用主实体的 `Id` 字段
4. **回退**：找不到本地化值时使用主实体的默认值
5. **语言码**：使用 ISO 639-1 标准（如 "zh", "ja", "en"）

