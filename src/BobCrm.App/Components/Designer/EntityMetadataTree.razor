@using AntDesign
@using BobCrm.App.Models
@using BobCrm.App.Services
@using System.Text.Json
@using System.Text.Json.Serialization
@using System.Linq

@inject AuthService Auth
@inject I18nService I18n
@inject IJSRuntime JS
@inject EntityDefinitionService EntityDefinitionService

@if (loading)
{
    <div style="padding:16px; text-align:center; color:#999">
        <Icon Type="@IconType.Outline.Loading" Spin />
        <div style="margin-top:8px; font-size:12px">@I18n.T("LBL_LOADING")...</div>
    </div>
}
else if (!string.IsNullOrWhiteSpace(error))
{
    <div style="padding:16px">
        <Alert Type="AlertType.Warning" Message="@error" ShowIcon="true" />
    </div>
}
else if (treeNodes.Count == 0)
{
    <div style="padding:16px; text-align:center; color:#999">
        <Icon Type="@IconType.Outline.Inbox" Style="font-size:32px; margin-bottom:8px" />
        <div style="font-size:12px">@I18n.T("LBL_NO_ENTITY_SELECTED")</div>
    </div>
}
else
{
    <div style="padding:8px">
    <div style="overflow-x: auto; width: 100%; padding-bottom: 8px;">
        <Tree TItem="EntityFieldTreeNode"
              DataSource="@treeNodes"
              ChildrenExpression="@(n => n.DataItem?.Children ?? Enumerable.Empty<EntityFieldTreeNode>())"
              TitleExpression="@(n => !string.IsNullOrWhiteSpace(n.DataItem?.DisplayName) ? n.DataItem!.DisplayName! : n.DataItem?.PropertyName ?? n.Key)"
              KeyExpression="@(n => n.DataItem?.Key ?? n.Key)"
              IconExpression="@(n => n.DataItem?.Icon)"
              IsLeafExpression="@(n => !(n.DataItem?.IsComplex ?? false) && !((n.DataItem?.Children?.Any()) ?? false))"
              ShowIcon="false"
              BlockNode="true"
              OnNodeLoadDelayAsync="OnNodeLoadDelayAsync">
            <TitleTemplate Context="node">
                @{
                    var meta = node.DataItem;
                    var isLeaf = node.IsLeaf;
                    var displayName = meta?.DisplayName;
                    var propertyName = meta?.PropertyName;
                    var showParens = !string.IsNullOrWhiteSpace(displayName) && !string.Equals(propertyName, displayName, StringComparison.OrdinalIgnoreCase);
                }
                <Tooltip Placement="@Placement.Right" MouseEnterDelay="0.5" OverlayClassName="compact-tooltip">
                    <TitleTemplate>
                        <div style="display:flex; flex-direction:column; gap:2px; padding:0">
                            <div style="font-weight:600; line-height:1.2">@displayName</div>
                            @if (showParens)
                            {
                                <div style="font-size:11px; color:#ccc; line-height:1.2">@propertyName</div>
                            }
                            <div style="display:flex; gap:4px; margin-top:4px">
                                <Tag Color="@GetDataTypeTagColor(meta?.DataType ?? string.Empty)" Style="margin:0; font-size:10px; line-height:16px">
                                    @meta?.DataType
                                </Tag>
                                @if (meta?.IsRequired == true)
                                {
                                    <Tag Color="@TagColor.Error" Style="margin:0; font-size:10px; line-height:16px">* Required</Tag>
                                }
                                <Tag Style="margin:0; font-size:10px; line-height:16px">@meta?.Source</Tag>
                            </div>
                        </div>
                    </TitleTemplate>
                    <ChildContent>
                        <div class="entity-tree-row"
                             draggable="@(meta != null && meta.IsDraggable && isLeaf)"
                             data-drag-type="entity-field"
                             data-drag-data="@meta?.Key"
                             @ondragstart="(e) => OnFieldDragStart(e, meta)"
                             @ondragend="OnFieldDragEnd">
                            <div class="entity-tree-content">
                                <Icon Type="@(node.Icon ?? IconType.Outline.FieldBinary)" Style="font-size:14px; color:#1890ff; margin-right:6px" />
                                <span class="entity-tree-text">
                                    <span class="entity-tree-name">@(string.IsNullOrWhiteSpace(displayName) ? propertyName : displayName)</span>
                                    @if (showParens)
                                    {
                                        <span class="entity-tree-prop">(@propertyName)</span>
                                    }
                                </span>
                            </div>
                        </div>
                    </ChildContent>
                </Tooltip>
            </TitleTemplate>
        </Tree>
    </div>
    </div>
}

@code {
    [Parameter] public string? EntityType { get; set; }

    [Parameter] public EventCallback<EntityFieldNode> OnFieldDragStarted { get; set; }

    private bool loading;
    private string? error;
    private string? loadedEntity;
    private List<EntityFieldTreeNode> treeNodes = new();

    protected override async Task OnParametersSetAsync()
    {
        if (loadedEntity == EntityType) return;
        await LoadEntityMetadata();
    }

    private async Task LoadEntityMetadata()
    {
        if (string.IsNullOrWhiteSpace(EntityType))
        {
            treeNodes = new();
            loadedEntity = null;
            return;
        }

        loading = true;
        error = null;
        StateHasChanged();

        try
        {
            EntityDefinitionDto? entityDef = null;
            foreach (var candidate in BuildEntityTypeCandidates(EntityType))
            {
                entityDef = await TryLoadDefinition(candidate);
                if (entityDef != null) break;
            }

            if (entityDef == null)
            {
                error = I18n.T("MSG_LOAD_FAILED");
                treeNodes = new();
                return;
            }

            treeNodes = BuildTreeNodes(entityDef);
            loadedEntity = EntityType;

            await JS.InvokeVoidAsync("console.log", $"[EntityMetadataTree] Loaded {treeNodes.Count} groups for {EntityType}");
        }
        catch (Exception ex)
        {
            error = $"Error: {ex.Message}";
            await JS.InvokeVoidAsync("console.error", $"[EntityMetadataTree] {ex.Message}");
        }
        finally
        {
            loading = false;
            StateHasChanged();
        }
    }

    private List<EntityFieldTreeNode> BuildTreeNodes(EntityDefinitionDto definition)
    {
        var list = new List<EntityFieldTreeNode>();
        var fieldGroups = (definition.Fields ?? new()).GroupBy(f => f.Source ?? "Custom").OrderBy(g => GetSourceOrder(g.Key));

        foreach (var group in fieldGroups)
        {
            var groupNode = new EntityFieldTreeNode
            {
                Key = $"group-{group.Key}",
                PropertyName = GetSourceDisplayName(group.Key),
                DisplayName = string.Empty,
                DataType = group.Key,
                Source = group.Key,
                IsRequired = false,
                IsDraggable = false,
                IsGroup = true,
                Icon = IconType.Outline.FolderOpen,
                Children = new List<EntityFieldTreeNode>()
            };

            foreach (var field in group.OrderBy(f => f.SortOrder).ThenBy(f => f.PropertyName))
            {
                var isComplex = field.IsEntityRef || string.Equals(field.DataType, "EntityRef", StringComparison.OrdinalIgnoreCase);
                var meta = new EntityFieldTreeNode
                {
                    Key = $"{definition.EntityRoute}:{field.PropertyName}",
                    PropertyName = field.PropertyName,
                    DisplayName = ResolveDisplay(field.DisplayName?.ToDictionary(k => k.Key, v => v.Value), field.PropertyName),
                    DataType = field.DataType,
                    IsRequired = field.IsRequired,
                    Source = group.Key,
                    IsDraggable = true,
                    Icon = GetFieldIcon(field.DataType),
                    IsComplex = isComplex,
                    ReferencedEntityId = field.ReferencedEntityId,
                    ReferencedEntityRoute = field.TableName,
                    ChildrenLoaded = false,
                    Children = new List<EntityFieldTreeNode>()
                };

                groupNode.Children.Add(meta);
            }

            list.Add(groupNode);
        }

        return list;
    }

    private async Task OnNodeLoadDelayAsync(TreeEventArgs<EntityFieldTreeNode> args)
    {
        var meta = args.Node?.DataItem;
        if (meta == null || !meta.IsComplex || meta.ChildrenLoaded) return;
        if (meta.ReferencedEntityId == null && string.IsNullOrWhiteSpace(meta.ReferencedEntityRoute)) return;

        try
        {
            EntityDefinitionDto? referenced = null;
            if (meta.ReferencedEntityId.HasValue)
            {
                referenced = await EntityDefinitionService.GetByIdAsync(meta.ReferencedEntityId.Value);
            }

            if (referenced == null && !string.IsNullOrWhiteSpace(meta.ReferencedEntityRoute))
            {
                foreach (var candidate in BuildEntityTypeCandidates(meta.ReferencedEntityRoute))
                {
                    referenced = await TryLoadDefinition(candidate);
                    if (referenced != null) break;
                }
            }

            if (referenced == null)
            {
                await JS.InvokeVoidAsync("console.warn", $"[EntityMetadataTree] No definition for ref {meta.ReferencedEntityRoute ?? meta.ReferencedEntityId?.ToString()}");
                meta.ChildrenLoaded = true;
                return;
            }

            var children = BuildTreeNodes(referenced).SelectMany(g => g.Children ?? new List<EntityFieldTreeNode>()).ToList();
            meta.Children = children;
            meta.ChildrenLoaded = true;
            await JS.InvokeVoidAsync("console.log", $"[EntityMetadataTree] Loaded {children.Count} children for {meta.PropertyName}");
            StateHasChanged();
        }
        catch (Exception ex)
        {
            await JS.InvokeVoidAsync("console.error", $"[EntityMetadataTree] Lazy load failed: {ex.Message}");
            meta.ChildrenLoaded = true;
        }
    }

    private async Task OnFieldDragStart(Microsoft.AspNetCore.Components.Web.DragEventArgs e, EntityFieldTreeNode? meta)
    {
        if (meta == null || meta.IsGroup || !meta.IsDraggable) return;
        try
        {
            var field = new EntityFieldNode
            {
                Key = meta.Key,
                PropertyName = meta.PropertyName,
                DisplayName = meta.DisplayName ?? string.Empty,
                DataType = meta.DataType,
                IsRequired = meta.IsRequired,
                Source = meta.Source,
                IsDraggable = true,
                SuggestedWidgetType = GetSuggestedWidgetType(meta.DataType, null, meta.IsRequired),
                Icon = meta.Icon
            };

            await OnFieldDragStarted.InvokeAsync(field);
            await JS.InvokeVoidAsync("console.log", $"[EntityMetadataTree] Dragging field: {meta.PropertyName}");
        }
        catch (Exception ex)
        {
            await JS.InvokeVoidAsync("console.error", $"[EntityMetadataTree] Drag start error: {ex.Message}");
        }
    }

    private void OnFieldDragEnd(Microsoft.AspNetCore.Components.Web.DragEventArgs e)
    {
        // no-op
    }

    private string ResolveDisplay(Dictionary<string, string?>? map, string fallback)
    {
        if (map == null || map.Count == 0) return fallback;
        var lang = I18n.CurrentLang;
        if (map.TryGetValue(lang, out var v) && !string.IsNullOrWhiteSpace(v))
        {
            return v!;
        }
        var any = map.Values.FirstOrDefault(x => !string.IsNullOrWhiteSpace(x));
        return any ?? fallback;
    }

    private string GetFieldIcon(string dataType)
    {
        return dataType switch
        {
            "String" => IconType.Outline.FileText,
            "Integer" or "Long" or "Decimal" => IconType.Outline.Number,
            "Boolean" => IconType.Outline.Check,
            "DateTime" or "Date" => IconType.Outline.Calendar,
            "Time" => IconType.Outline.ClockCircle,
            "Text" => IconType.Outline.FileText,
            "Guid" => IconType.Outline.Key,
            "EntityRef" => IconType.Outline.Cluster,
            _ => IconType.Outline.Appstore
        };
    }

    private TagColor GetDataTypeTagColor(string dataType)
    {
        return dataType switch
        {
            "String" => TagColor.Blue,
            "Integer" or "Long" or "Decimal" => TagColor.Green,
            "Boolean" => TagColor.Orange,
            "DateTime" or "Date" or "Time" => TagColor.Purple,
            "Text" => TagColor.Cyan,
            "Guid" => TagColor.GeekBlue,
            "EntityRef" => TagColor.Processing,
            _ => TagColor.Default
        };
    }

    private int GetSourceOrder(string source)
    {
        return source switch
        {
            "Custom" => 1,
            "Base" => 2,
            "Archive" => 3,
            "Audit" => 4,
            "Tree" => 5,
            _ => 99
        };
    }

    private string GetSourceDisplayName(string source)
    {
        return source switch
        {
            "Custom" => I18n.T("LBL_CUSTOM_FIELDS"),
            "Base" => I18n.T("LBL_BASE_FIELDS"),
            "Archive" => I18n.T("LBL_ARCHIVE_FIELDS"),
            "Audit" => I18n.T("LBL_AUDIT_FIELDS"),
            "Tree" => I18n.T("LBL_TREE_FIELDS"),
            _ => source
        };
    }

    private string GetSuggestedWidgetType(string dataType, int? length, bool isRequired)
    {
        return dataType switch
        {
            "String" when length <= 100 => "Input",
            "String" when length > 100 => "TextArea",
            "Integer" or "Long" => "InputNumber",
            "Decimal" => "InputNumber",
            "Boolean" => "Checkbox",
            "DateTime" => "DatePicker",
            "Date" => "DatePicker",
            "Time" => "TimePicker",
            "Guid" => "Input",
            "Text" => "TextArea",
            "EntityRef" => "Select",
            _ => "Input"
        };
    }

    private async Task<EntityDefinitionDto?> TryLoadDefinition(string candidate)
    {
        var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true, Converters = { new JsonStringEnumConverter() } };

        var response = await Auth.GetWithRefreshAsync($"/api/entity-definitions/by-type/{Uri.EscapeDataString(candidate)}");
        if (response.IsSuccessStatusCode)
        {
            var content = await response.Content.ReadAsStringAsync();
            return JsonSerializer.Deserialize<EntityDefinitionDto>(content, options);
        }

        response = await Auth.GetWithRefreshAsync($"/api/entities/{Uri.EscapeDataString(candidate)}/definition");
        if (response.IsSuccessStatusCode)
        {
            var content = await response.Content.ReadAsStringAsync();
            return JsonSerializer.Deserialize<EntityDefinitionDto>(content, options);
        }

        await JS.InvokeVoidAsync("console.warn", $"[EntityMetadataTree] Metadata load failed for {candidate}: {response.StatusCode}");
        return null;
    }

    private IEnumerable<string> BuildEntityTypeCandidates(string? entity)
    {
        var cleaned = entity?.Trim().Trim('/').ToLowerInvariant() ?? string.Empty;
        if (string.IsNullOrWhiteSpace(cleaned)) yield break;

        if (cleaned.StartsWith("entity_"))
        {
            cleaned = cleaned["entity_".Length..];
        }

        yield return cleaned;
        if (cleaned.EndsWith("s"))
        {
            yield return cleaned.TrimEnd('s');
        }
        else
        {
            yield return $"{cleaned}s";
        }
    }

    private class EntityFieldTreeNode
    {
        public string Key { get; set; } = string.Empty;
        public string PropertyName { get; set; } = string.Empty;
        public string? DisplayName { get; set; }
        public string DataType { get; set; } = string.Empty;
        public string Source { get; set; } = "Custom";
        public bool IsRequired { get; set; }
        public bool IsDraggable { get; set; }
        public bool IsGroup { get; set; }
        public bool IsComplex { get; set; }
        public Guid? ReferencedEntityId { get; set; }
        public string? ReferencedEntityRoute { get; set; }
        public bool ChildrenLoaded { get; set; }
        public string Icon { get; set; } = IconType.Outline.FieldBinary;
        public List<EntityFieldTreeNode> Children { get; set; } = new();
    }
}

<style>
    .entity-tree-row {
        display: flex;
        align-items: center;
        padding: 2px 4px;
        border-radius: 4px;
        width: 100%;
        overflow: hidden;
        height: 24px;
    }

    .entity-tree-row:hover {
        background: #e6f7ff;
    }

    .entity-tree-content {
        display: flex;
        align-items: center;
        min-width: 0;
        width: 100%;
    }

    .entity-tree-text {
        display: flex;
        align-items: baseline;
        gap: 4px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .entity-tree-name {
        font-size: 12px;
        color: #333;
    }

    .entity-tree-prop {
        font-size: 11px;
        color: #999;
    }
</style>
